#include "tcp_server_demo.h"
#include "lwip/opt.h"
#include "lwip_comm.h"
#include "led.h"
#include "lwip/lwip_sys.h"
#include "lwip/api.h"
#include "Queue.h"
#include "message.h"
#include "stdbool.h"




u8 tcp_server_recvbuf[TCP_SERVER_RX_BUFSIZE];	//TCP客户端接收数据缓冲区
u8 tcp_server_sendbuf[TCP_SERVER_SX_BUFSIZE];	
u8 tcp_server_flag;								//TCP服务器数据发送标志位

extern struct interQueue *FMQ;


//TCP客户端任务
#define TCPSERVER_PRIO		6
//任务堆栈大小
#define TCPSERVER_STK_SIZE	300
//任务堆栈
OS_STK TCPSERVER_TASK_STK[TCPSERVER_STK_SIZE];

//tcp服务器任务
static void tcp_server_thread(void *arg)
{
	OS_CPU_SR cpu_sr;
	u32 data_len = 0;
	struct pbuf *q;
	err_t err,recv_err;
	u8 remot_addr[4];
	struct netconn *conn, *newconn=NULL, *connSecond=NULL;
	static ip_addr_t ipaddr;
	static u16_t 			port;
    static bool newConFlag = false;
	
    STM sendMsg;
	
	LWIP_UNUSED_ARG(arg);

	conn = netconn_new(NETCONN_TCP);  //创建一个TCP链接
	netconn_bind(conn,IP_ADDR_ANY,TCP_SERVER_PORT);  //绑定端口 8号端口
	netconn_listen(conn);  		//进入监听模式
	conn->recv_timeout = 20;  	//禁止阻塞线程 等待10ms
	while (1) 
	{
		//printf("tcp_server_demo.c 等待请求%d\r\n",err);
        err = netconn_accept(conn,&connSecond);  //接收连接请求
        //printf("tcp_server_demo.c 收到请求%d,%d\r\n",err,(int)(connSecond));
		if(err==ERR_OK)//有新的连接
        {   
            if(newconn!=NULL&&newConFlag)//之前有一个连接
            {
                
                netconn_close(newconn);//剔除之前的连接
				netconn_delete(newconn);
                newconn = connSecond;
                //printf("tcp_server_demo.c new连接\r\n");
            }
            else//
            {
                newconn = connSecond;
            }
            newconn->recv_timeout = 20;
            newConFlag = true;
        }
		if ((err == ERR_OK || newConFlag)&& newconn!=NULL)    //处理新连接的数据
		{ 
			
            struct netbuf *recvbuf;
            if(err == ERR_OK)
           {
                netconn_getaddr(newconn,&ipaddr,&port,0); //获取远端IP地址和端口号
                
                remot_addr[3] = (uint8_t)(ipaddr.addr >> 24); 
                remot_addr[2] = (uint8_t)(ipaddr.addr>> 16);
                remot_addr[1] = (uint8_t)(ipaddr.addr >> 8);
                remot_addr[0] = (uint8_t)(ipaddr.addr);
                printf("tcp_server_demo.c 主机%d.%d.%d.%d连接上服务器,主机端口号为:%d\r\n",remot_addr[0], remot_addr[1],remot_addr[2],remot_addr[3],port);
			}
			//while(1)
            if(newConFlag)
			{
				
				if(FMQ->QueueCount>0) //有数据要发送
				{
					GetAndDelQueueinter(sizeof(STM), &sendMsg, FMQ);
				/*	err = netconn_write(newconn ,&sendMsg,sendMsg.len+6,NETCONN_COPY);
				  if(err != ERR_OK)
					{
						printf("tcp_server_demo.c 发送失败\r\n");
					}*/
				}
//				printf("----1\r\n"); 
				if((recv_err = netconn_recv(newconn,&recvbuf)) == ERR_OK)  	//接收到数据
				{		
					OS_ENTER_CRITICAL(); //关中断
					memset(tcp_server_recvbuf,0,TCP_SERVER_RX_BUFSIZE);  //数据接收缓冲区清零
					for(q=recvbuf->p;q!=NULL;q=q->next)  //遍历完整个pbuf链表
					{
						//判断要拷贝到TCP_SERVER_RX_BUFSIZE中的数据是否大于TCP_SERVER_RX_BUFSIZE的剩余空间，如果大于
						//的话就只拷贝TCP_SERVER_RX_BUFSIZE中剩余长度的数据，否则的话就拷贝所有的数据
						if(q->len > (TCP_SERVER_RX_BUFSIZE-data_len)) 
                        {
							memcpy(tcp_server_recvbuf+data_len,q->payload,(TCP_SERVER_RX_BUFSIZE-data_len));//拷贝数据
                            //data_len = TCP_SERVER_RX_BUFSIZE;
                        }
						else 
                        {
							memcpy(tcp_server_recvbuf+data_len,q->payload,q->len);
                        }
                        data_len += q->len;  	
                        
						if(data_len > TCP_SERVER_RX_BUFSIZE) 
						{
							data_len=TCP_SERVER_RX_BUFSIZE;
							printf("tcp_server_demo.c data_len > TCP_SERVER_RX_BUFSIZE\r\n");
                            //newConFlag = false;
							break; //超出TCP客户端接收数组,跳出	
						}
					}
					OS_EXIT_CRITICAL();  //开中断		
//                    printf("||||2\r\n");                    
					MessageHandle(tcp_server_recvbuf,data_len);
											
					printf("tcp_server_demo.c  tcp_server_recvbuf[0]=%x,data_len=%d\r\n",tcp_server_recvbuf[0],data_len);  //通过串口发送接收到的数据
                    data_len=0;  //复制完成后data_len要清零。
					netbuf_delete(recvbuf);
				}else if(recv_err == ERR_CLSD)  //关闭连接
				{
					netconn_close(newconn);
					netconn_delete(newconn);
					newConFlag = false;
                    printf("tcp_server_demo.c 主机:%d.%d.%d.%d断开与服务器的连接\r\n",remot_addr[0], remot_addr[1],remot_addr[2],remot_addr[3]);
					
                    //break;
				}

			}
		}
         OSTimeDlyHMSM(0,0,0,5);
	}
}


//创建TCP服务器线程
//返回值:0 TCP服务器创建成功
//		其他 TCP服务器创建失败
INT8U tcp_server_init(void)
{
	INT8U res;
	OS_CPU_SR cpu_sr;
	
	OS_ENTER_CRITICAL();	//关中断
	res = OSTaskCreate(tcp_server_thread,(void*)0,(OS_STK*)&TCPSERVER_TASK_STK[TCPSERVER_STK_SIZE-1],TCPSERVER_PRIO); //创建TCP服务器线程
	OS_EXIT_CRITICAL();		//开中断
	
	return res;
}


